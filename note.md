## CPU密集型与I/O密集型
CPU密集型：
    通常指python中计算和处理代码，如计算pi的值，业务中循环遍历字典的内容...

I/O密集型：
    大部分时间将花在等待网络或其他I/O设备上，如网络请求，磁盘读取文件...

## 并发、并行、多任务
> 首先需要清楚，并发与并行是两个概念

### 1. 并发
当我们说两个任务并发时，是指这些任务同时发生。
比如：需要烘培两种不同的面包，不必在完成第一种面包后，才开始制作第二种面包。
这两种面包制作的子步骤可以交替进行，即在不同的任务之前切换。
这种任务之间的切换，就是并发行为

### 2. 并行
并发意味着多个任务同时进行，但不意味着他们并行运行。
当说某事并行运行时，意思是不仅有两个或多个任务同时发生，而且在同时执行。

仍以制作两种不同的面包为例，假设有两个面包师傅，一人制作一种。
两人同时开始属于并行运行，因为有两个不同的任务在同时执行。

> 并发与并行区别

1. 并发，有多个任务同时发生，但在特定时刻，只有一个任务在运行
2. 并行，有多个任务同时发生，且在特定时刻，有多个任务同时运行

分类|并发|并行
---|---|---
区别|特定时刻，只有一个任务在运行|特定时刻，多个任务同时运行
区别|可在只有一个内核的CPU上运行|不可在只有一个核心的CPU上运行

### 3. 多任务
两种主要的多任务处理：抢占式多任务处理、协同多任务处理

- 抢占式多任务处理

由操作系统决定如何通过一个称为时间片的过程，在当前正在执行的任务之间切换。
当操作系统在任务之间切换时，称之为抢占

- 协同多任务处理

不是依赖操作系统来决定何时在当前正在执行的任务之间切换，而是在应用程序中，显示地编写代码，可让其他任务先去运行。
即”先暂停我的任务一段时间，让其他任务先执行“

协同多任务处理优势：
asyncio使用协同多任务处理来实现并发性。
当应用达到可以等等一段时间以返回结果的时间点时，在代码中显示标记它。
这允许其他代码在等待结果返回后台时运行。
一旦标记的任务完成，应用就“醒来”继续执行该任务。
这是一种并发形式，因为可同时启动多个任务，但重要的是，**这不是并行模式，因为他们不会同时执行代码**


## 进程、线程、多线程、多处理

### 1. 进程
进程是具有其他应用个欻是无法访问的内存空间的应用程序运行状态。


### 2. 线程
线程可被认为轻量级进程。
线程是操作系统可以管理的最小结构。
线程间共享创建进程的内存。
线程与创建它的进程关联。
一个进程总是至少有一个与之关联的线程，通常称为*主线程*
一个进程还可以创建其他线程，通常称为*工作线程或后台线程*

主线程和后台线程可同时执行其他工作。

code: [./chapter01/a001简单应用中的进程与线程.py](./chapter01/a001简单应用中的进程与线程.py)

## 全局解释器锁GIL

## 单线程并发

## 事件循环

